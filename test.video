Skip to content
 
Search Gists
Search...
All gists
Back to GitHub
@v01dpr1mr0s3
v01dpr1mr0s3/openrouter_markdown.js Secret
Created last month • Report abuse
Code
Revisions
1
Clone this repository at &lt;script src=&quot;https://gist.github.com/v01dpr1mr0s3/4c252924bc5be42efbbcba3639da383e.js&quot;&gt;&lt;/script&gt;
<script src="https://gist.github.com/v01dpr1mr0s3/4c252924bc5be42efbbcba3639da383e.js"></script>
OpenRouter Better Markdown Generator
openrouter_markdown.js
// ==UserScript==
// @name         OpenRouter Better Markdown Generator
// @namespace    http://tampermonkey.net/
// @version      3.1
// @description  Aggregates chat data and generates a markdown file for download.
// @author       Gemini & Void
// @match        *://openrouter.ai/chat*
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // --- Create and style the UI element ---
    // (This part is unchanged)
    const mdButton = document.createElement('div');
    mdButton.textContent = 'MD';
    Object.assign(mdButton.style, {
        position: 'fixed', right: '20px', bottom: '20px', cursor: 'pointer',
        backgroundColor: 'white', border: '1px solid black', padding: '10px',
        zIndex: '9999', userSelect: 'none'
    });
    document.body.appendChild(mdButton);

    // --- Establish IndexedDB Connection Once ---
    let db;
    const dbName = 'openrouter:playground:v3';

    indexedDB.open(dbName).onsuccess = (event) => {
        db = event.target.result;
        console.log('DB connection ready.');
    };

    // --- NEW: A helper function to get a single item from the DB.
    // This function encapsulates the entire transaction for one 'get' operation.
    // This is the key to making the solution robust.
    function getFromDB(key) {
        return new Promise((resolve, reject) => {
            if (!db) return reject('Database is not connected.');
            const transaction = db.transaction([db.name], 'readonly'); // Use db.name as store name
            const store = transaction.objectStore(db.name);
            const request = store.get(key);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // --- Main logic, now using the robust helper function ---
    async function generateAndDownloadMarkdown(roomId) {
        // --- Fetch initial data in parallel ---
        const [manifestData, roomData] = await Promise.all([
            getFromDB(`v3:manifest:${roomId}`),
            getFromDB(`v3:room:${roomId}`)
        ]);

        if (!manifestData?.value) {
            throw new Error('Could not find chat data for this room.');
        }

        const { characterIds, messageIds } = manifestData.value;

        // --- Build characters map ---
        const charactersMap = {};
        const characterPromises = characterIds.map(charId => getFromDB(`v3:character:${charId}`));
        const allCharacterData = await Promise.all(characterPromises);

        for (const [i, charData] of allCharacterData.entries()) {
            if (charData?.value) {
                const charId = characterIds[i];
                charactersMap[charId] = charData.value.modelInfo?.endpoint?.model?.short_name || charData.value.modelInfo?.endpoint?.model?.name || 'Unknown Model';
            }
        }

        // --- Sequentially build the conversation log ---
        const fullConversation = [];
        for (const msgId of messageIds) {
            // Fetch message and content for one ID
            const [messageData, contentData] = await Promise.all([
                getFromDB(`v3:message:${msgId}`),
                getFromDB(`v3:content:${msgId}`)
            ]);

            if (messageData?.value && contentData) {
                let entry = null;
                if (messageData.value.type === 'assistant') {
                    const role = charactersMap[messageData.value.characterId] || 'Assistant';
                    entry = { role, content: contentData.value };
                } else if (messageData.value.type === 'user') {
                    entry = { role: 'User', content: contentData.value };
                }
                if (entry) fullConversation.push(entry);
            }
        }

        // --- Format and Download ---
        const roomTitle = roomData?.value?.title || "chat_export";
        const markdownContent = fullConversation
            .map(entry => `**${entry.role}:**\n\n${entry.content}`)
            .join('\n\n---\n\n');

        const sanitizedTitle = roomTitle.replace(/[\/\\?%*:|"<>]/g, '-');
        const filename = `orc-chat-${sanitizedTitle}.md`;
        const blob = new Blob([markdownContent], { type: 'text/markdown;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }

    // --- The Click Handler (now much cleaner) ---
    mdButton.addEventListener('click', async () => {
        const roomId = new URL(window.location.href).searchParams.get('room');
        if (!roomId) {
            alert('Room ID not found in URL.');
            return;
        }

        const originalText = mdButton.textContent;
        mdButton.textContent = '...';
        mdButton.style.pointerEvents = 'none';

        try {
            await generateAndDownloadMarkdown(roomId);
        } catch (error) {
            console.error('An error occurred during export:', error);
            alert(`An error occurred during export: ${error.message}`);
        } finally {
            mdButton.textContent = originalText;
            mdButton.style.pointerEvents = 'auto';
        }
    });

})();
@v0Idpr1mr0s3
Comment
 
Leave a comment
 
Footer
© 2025 GitHub, Inc.
Footer navigation
Terms
Privacy
Security
Status
Community
Docs
Contact
Manage cookies
Do not share my personal information
